---
layout : single
date: 2014-12-19
title : SICP 课后练习题1.5
math: true
categories : 
  - 编程语言
tags : 
  - lisp
  - SICP
---

#### 练习1.5   Ben Bitdiddle发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是正则序。他定义了下面两个过程
```scheme
    (define (p) (p))
    
    (define (test x y)
      (if (= x 0)
          0
          y))
```          
而后他求值下面的表达式：
```scheme
    (test 0 (p))
```    
如果某个解释器采用的是应用序求值，Ben会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的回答做出解释。（无论采用正则序或者应用序，假定特殊形式if的求值规则总是一样的。其中的谓词部分先行求值，根据其结果确定随后求值的子表达式部分。）

  练习1.5 『完全展开而后规约』的求值模型为正则序求值，『先求值参数而后应用』的方式为应用序求值，因此，在应用序求值的模式下，执行`(test 0 (p))`时会先求`(p)`这个表达式的值，而根据定义`(define (p) (p))`执行`(p)`会造成递归调用，解释器陷入死循环。而在正则序求值模式下，会先展开`test`过程，根据需要再决定是否执行`(p)`，在本例中，由于传入的`x`等于`0`，所以`(p)`不会被执行，因此不会陷入死循环。
  
  所以，根据以上分析，如果解释器采用的是应用序求值，则解释器陷入死循环，如果是采用正则序求值，则解释器输出`;Value: 0`。